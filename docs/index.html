<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Economy Optimizer (Aggressive)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 {
            text-align: center; margin-bottom: 30px; color: #a78bfa;
            font-size: 2.5em; text-shadow: 0 0 20px rgba(167, 139, 250, 0.4);
        }
        .controls {
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 25px;
            margin-bottom: 30px; border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .control-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #a78bfa; }
        .slider-container { display: flex; align-items: center; gap: 15px; }
        input[type="range"] {
            flex: 1; height: 8px; border-radius: 5px; background: #334155;
            outline: none; -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            border-radius: 50%; background: #a78bfa; cursor: pointer;
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.7);
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .stat-card {
            background: rgba(51, 65, 85, 0.5); padding: 15px; border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .stat-card.highlight {
            background: rgba(167, 139, 250, 0.15); border: 1px solid rgba(167, 139, 250, 0.5);
        }
        .stat-label { font-size: 0.85em; opacity: 0.8; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { font-size: 1.5em; font-weight: bold; color: #fff; }
        .button-row { display: flex; gap: 10px; margin-top: 20px; }
        button {
            border: none; padding: 12px 24px; border-radius: 8px; color: white;
            font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 1em; flex: 1;
        }
        .optimize-btn { background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%); }
        .optimize-btn:hover { background: linear-gradient(135deg, #a78bfa 0%, #7c3aed 100%); transform: translateY(-2px); }
        .reset-btn { background: #475569; }
        .reset-btn:hover { background: #64748b; }
        
        .chart-container {
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 20px;
            height: 400px; margin-bottom: 30px; border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .table-container {
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 20px;
            overflow-x: auto; border: 1px solid rgba(255, 255, 255, 0.1);
        }
        table { width: 100%; border-collapse: collapse; }
        th {
            background: rgba(15, 23, 42, 0.8); padding: 15px; text-align: left;
            color: #a78bfa; border-bottom: 2px solid #334155; white-space: nowrap;
        }
        td { padding: 12px 15px; border-bottom: 1px solid #334155; }
        tr:hover { background: rgba(255, 255, 255, 0.05); }
        
        .val-currency { color: #4ade80; font-family: monospace; }
        .val-pixels { color: #a78bfa; font-weight: bold; }
        .decision-tag {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 0.8em; margin-right: 4px; margin-bottom: 2px;
        }
        .tag-speed { background: rgba(56, 189, 248, 0.2); color: #38bdf8; border: 1px solid rgba(56, 189, 248, 0.4); }
        .tag-cap { background: rgba(251, 146, 60, 0.2); color: #fb923c; border: 1px solid rgba(251, 146, 60, 0.4); }
        
        .calculating { opacity: 0.5; pointer-events: none; cursor: wait; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Pixel Economy Optimizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="inactiveHours">Inactive Hours per Day (Sleep + Work):</label>
                <div class="slider-container">
                    <input type="range" id="inactiveHours" min="0" max="24" value="16" step="1">
                    <span class="slider-value" id="inactiveValue">16h</span>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card highlight">
                    <div class="stat-label">Total Pixels (Day 30)</div>
                    <div class="stat-value" id="totalPixels" style="color: #a78bfa;">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Regen Rate</div>
                    <div class="stat-value" id="finalRate">30s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Capacity</div>
                    <div class="stat-value" id="finalCap">60</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Leftover Currency</div>
                    <div class="stat-value" id="finalCurrency">0</div>
                </div>
            </div>
            
            <div class="button-row">
                <button class="optimize-btn" onclick="runAutoOptimize()">
                    ‚ö° Auto-Optimize (Aggressive)
                </button>
                <button class="reset-btn" onclick="resetSim()">
                    ‚ùå Reset
                </button>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Day</th>
                        <th>Start Bank</th>
                        <th>Purchases</th>
                        <th>Pixel Yield</th>
                        <th>Total Pixels</th>
                        <th>End Bank</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const CONSTANTS = {
            PIXELS_PER_CURRENCY: 5,
            START_CURRENCY: 1120,
            START_RATE: 30,
            START_CAP: 60,
            COST_CAP: 50,
            GAIN_CAP: 5,
            COST_SPEED: 500,
            GAIN_SPEED: 1,
            MIN_RATE: 15
        };

        // --- STATE ---
        let state = {
            inactiveHours: 16,
            upgrades: {} // { dayNum: { speed: 0, cap: 0 } }
        };

        let chartInstance = null;

        // --- CORE SIMULATION LOGIC ---

        // Helper: Clone stats object
        function cloneStats(s) {
            return { ...s };
        }

        // Helper: Project outcome from a specific day to Day 30 without changing state
        // This is the "Crystal Ball" function for the optimizer
        function projectRestOfMonth(startDay, currentStats, inactiveHours) {
            let simStats = cloneStats(currentStats);
            
            // Loop from current day to end of month
            // We assume NO MORE upgrades are bought after today for this projection
            for (let d = startDay; d <= 30; d++) {
                // 1. Calculate Daily Income based on current stats
                let activeSec = (24 - inactiveHours) * 3600;
                let inactiveSec = inactiveHours * 3600;
                
                // Active yield (uncapped)
                let activeYield = activeSec / simStats.regenRate;
                
                // Inactive yield (capped)
                let inactiveRaw = inactiveSec / simStats.regenRate;
                let inactiveYield = Math.min(inactiveRaw, simStats.capacity);
                
                let dailyPixels = activeYield + inactiveYield;
                let dailyEarnings = dailyPixels / CONSTANTS.PIXELS_PER_CURRENCY;
                
                // 2. Accumulate
                simStats.totalPixels += dailyPixels;
                simStats.currency += dailyEarnings;
            }
            return simStats.totalPixels;
        }

        // The "Brain" - Aggressive Optimizer
        function findAggressivePath(inactiveHours) {
            let optimalUpgrades = {};
            
            // We need to track the state progressively as we make decisions
            let currentStats = {
                regenRate: CONSTANTS.START_RATE,
                capacity: CONSTANTS.START_CAP,
                currency: CONSTANTS.START_CURRENCY,
                totalPixels: 0
            };

            for (let day = 1; day <= 30; day++) {
                optimalUpgrades[day] = { speed: 0, cap: 0 };
                
                // THE AGGRESSIVE LOOP
                // Keep buying upgrades on THIS day until we can't or it's not worth it
                let keepBuying = true;
                
                while (keepBuying) {
                    let bestMove = 'none';
                    // 1. Calculate Baseline (Stop buying and just finish the month)
                    let baselineTotal = projectRestOfMonth(day, currentStats, inactiveHours);
                    let bestTotal = baselineTotal;

                    // 2. Simulate Buying Speed (if affordable)
                    let speedTotal = -1;
                    let canAffordSpeed = currentStats.currency >= CONSTANTS.COST_SPEED;
                    let notMaxed = currentStats.regenRate > CONSTANTS.MIN_RATE;
                    
                    if (canAffordSpeed && notMaxed) {
                        let tempStats = cloneStats(currentStats);
                        tempStats.currency -= CONSTANTS.COST_SPEED;
                        tempStats.regenRate -= CONSTANTS.GAIN_SPEED;
                        speedTotal = projectRestOfMonth(day, tempStats, inactiveHours);
                    }

                    // 3. Simulate Buying Cap (if affordable)
                    let capTotal = -1;
                    let canAffordCap = currentStats.currency >= CONSTANTS.COST_CAP;
                    
                    if (canAffordCap) {
                        let tempStats = cloneStats(currentStats);
                        tempStats.currency -= CONSTANTS.COST_CAP;
                        tempStats.capacity += CONSTANTS.GAIN_CAP;
                        capTotal = projectRestOfMonth(day, tempStats, inactiveHours);
                    }

                    // 4. Compare Scenarios
                    // We only buy if it STRICTLY improves the total pixel count
                    if (speedTotal > bestTotal) {
                        bestMove = 'speed';
                        bestTotal = speedTotal;
                    }
                    
                    // If Cap is better than Baseline AND better than Speed (or equal/speed impossible)
                    if (capTotal > bestTotal) {
                        bestMove = 'cap';
                        bestTotal = capTotal;
                    }

                    // 5. Execute Decision
                    if (bestMove === 'speed') {
                        currentStats.currency -= CONSTANTS.COST_SPEED;
                        currentStats.regenRate -= CONSTANTS.GAIN_SPEED;
                        optimalUpgrades[day].speed++;
                    } else if (bestMove === 'cap') {
                        currentStats.currency -= CONSTANTS.COST_CAP;
                        currentStats.capacity += CONSTANTS.GAIN_CAP;
                        optimalUpgrades[day].cap++;
                    } else {
                        // No move improved our score, or we are broke.
                        keepBuying = false; 
                    }
                } // End While Loop (Buying Spree)

                // 6. Process the Day Passing (Earn money for tomorrow)
                let activeSec = (24 - inactiveHours) * 3600;
                let inactiveSec = inactiveHours * 3600;
                
                let activeYield = activeSec / currentStats.regenRate;
                let inactiveRaw = inactiveSec / currentStats.regenRate;
                let inactiveYield = Math.min(inactiveRaw, currentStats.capacity);
                
                let dailyPixels = activeYield + inactiveYield;
                let dailyEarnings = dailyPixels / CONSTANTS.PIXELS_PER_CURRENCY;
                
                currentStats.totalPixels += dailyPixels;
                currentStats.currency += dailyEarnings;
            }

            return optimalUpgrades;
        }

        // Standard Simulator for UI Rendering
        function simulateFullMonth() {
            let history = [];
            let stats = {
                regenRate: CONSTANTS.START_RATE,
                capacity: CONSTANTS.START_CAP,
                currency: CONSTANTS.START_CURRENCY,
                totalPixels: 0
            };

            for (let day = 1; day <= 30; day++) {
                let startBank = stats.currency;
                
                // Check for upgrades for this day
                let dayUpgrades = state.upgrades[day] || { speed: 0, cap: 0 };
                
                // Apply Costs & Stats immediately (assuming bought at start of day)
                let cost = (dayUpgrades.speed * CONSTANTS.COST_SPEED) + (dayUpgrades.cap * CONSTANTS.COST_CAP);
                stats.currency -= cost;
                stats.regenRate -= (dayUpgrades.speed * CONSTANTS.GAIN_SPEED);
                stats.capacity += (dayUpgrades.cap * CONSTANTS.GAIN_CAP);

                // Calculate Income
                let activeSec = (24 - state.inactiveHours) * 3600;
                let inactiveSec = state.inactiveHours * 3600;
                
                let activeYield = activeSec / stats.regenRate;
                let inactiveRaw = inactiveSec / stats.regenRate;
                let inactiveYield = Math.min(inactiveRaw, stats.capacity);
                
                let dailyPixels = activeYield + inactiveYield;
                let dailyEarnings = dailyPixels / CONSTANTS.PIXELS_PER_CURRENCY;
                
                stats.totalPixels += dailyPixels;
                stats.currency += dailyEarnings;

                history.push({
                    day: day,
                    startBank: startBank,
                    upgrades: dayUpgrades,
                    dailyPixels: dailyPixels,
                    totalPixels: stats.totalPixels,
                    endBank: stats.currency,
                    currentRate: stats.regenRate,
                    currentCap: stats.capacity
                });
            }
            return history;
        }

        // --- UI FUNCTIONS ---

        function updateUI(history) {
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            
            history.forEach(row => {
                let tr = document.createElement('tr');
                
                let upgradeHtml = '';
                if(row.upgrades.speed > 0) upgradeHtml += `<span class="decision-tag tag-speed">‚ö° ${row.upgrades.speed}x Speed</span>`;
                if(row.upgrades.cap > 0) upgradeHtml += `<span class="decision-tag tag-cap">üì¶ ${row.upgrades.cap}x Cap</span>`;
                if(upgradeHtml === '') upgradeHtml = '<span style="opacity:0.3">‚Äî</span>';

                tr.innerHTML = `
                    <td style="color: #a78bfa; font-weight:bold;">${row.day}</td>
                    <td class="val-currency">${row.startBank.toFixed(2)}</td>
                    <td>${upgradeHtml}</td>
                    <td class="val-pixels">+${Math.round(row.dailyPixels).toLocaleString()}</td>
                    <td style="opacity: 0.8">${Math.round(row.totalPixels).toLocaleString()}</td>
                    <td class="val-currency">${row.endBank.toFixed(2)}</td>
                `;
                tableBody.appendChild(tr);
            });

            // Update Stats Cards
            let final = history[29];
            document.getElementById('totalPixels').innerText = Math.round(final.totalPixels).toLocaleString();
            document.getElementById('finalRate').innerText = final.currentRate + 's';
            document.getElementById('finalCap').innerText = final.currentCap + 'px';
            document.getElementById('finalCurrency').innerText = final.endBank.toFixed(2);

            // Update Chart
            updateChart(history);
        }

        function updateChart(history) {
            const ctx = document.getElementById('mainChart').getContext('2d');
            if(chartInstance) chartInstance.destroy();

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: history.map(h => `Day ${h.day}`),
                    datasets: [{
                        label: 'Total Pixels Placed',
                        data: history.map(h => h.totalPixels),
                        borderColor: '#a78bfa',
                        backgroundColor: 'rgba(167, 139, 250, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#cbd5e1' } },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        x: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        function runAutoOptimize() {
            let btn = document.querySelector('.optimize-btn');
            btn.innerHTML = '‚öôÔ∏è Calculating...';
            btn.classList.add('calculating');

            setTimeout(() => {
                state.upgrades = findAggressivePath(state.inactiveHours);
                let history = simulateFullMonth();
                updateUI(history);
                
                btn.innerHTML = '‚ö° Auto-Optimize (Aggressive)';
                btn.classList.remove('calculating');
            }, 50);
        }

        function resetSim() {
            state.upgrades = {};
            let history = simulateFullMonth();
            updateUI(history);
        }

        // Init
        document.getElementById('inactiveHours').addEventListener('input', (e) => {
            document.getElementById('inactiveValue').innerText = e.target.value + 'h';
            state.inactiveHours = parseInt(e.target.value);
            // Re-run current upgrades with new hours or reset? 
            // Usually safer to reset or re-calc. Let's re-calc sim with existing upgrades.
            let history = simulateFullMonth();
            updateUI(history);
        });

        // Run once on load
        resetSim();

    </script>
</body>
</html>
