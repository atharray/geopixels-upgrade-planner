<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoPixels Upgrade Planner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        /* Base styles from paint.html for dark theme */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1600px; margin: 0 auto; } /* Increased max-width */
        h1 {
            text-align: center; margin-bottom: 30px; color: #a78bfa;
            font-size: 2.5em; text-shadow: 0 0 20px rgba(167, 139, 250, 0.4);
        }
        .controls {
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 25px;
            margin-bottom: 30px; border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .control-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #a78bfa; }
        .slider-container { display: flex; align-items: center; gap: 15px; }
        input[type="range"] {
            flex: 1; height: 8px; border-radius: 5px; background: #334155;
            outline: none; -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            border-radius: 50%; background: #a78bfa; cursor: pointer;
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.7);
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .stat-card {
            background: rgba(51, 65, 85, 0.5); padding: 15px; border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .stat-card.highlight {
            background: rgba(167, 139, 250, 0.15); border: 1px solid rgba(167, 139, 250, 0.5);
        }
        .stat-label { font-size: 0.85em; opacity: 0.8; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { font-size: 1.5em; font-weight: bold; color: #fff; }
        .button-row { display: flex; gap: 10px; margin-top: 20px; }
        button {
            border: none; padding: 12px 24px; border-radius: 8px; color: white;
            font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 1em; flex: 1;
        }
        .optimize-btn { background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%); }
        .optimize-btn:hover { background: linear-gradient(135deg, #a78bfa 0%, #7c3aed 100%); transform: translateY(-2px); }
        .reset-btn { background: #475569; }
        .reset-btn:hover { background: #64748b; }
        .chart-container {
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 20px;
            height: 400px; margin-bottom: 30px; border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Table Layout for Summary + Detail */
        .data-layout {
            display: flex;
            gap: 20px;
        }
        .table-container {
            flex: 3; /* Main table takes more space */
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 20px;
            overflow-x: auto; border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .summary-container {
            flex: 1; /* Summary table takes less space */
            background: rgba(30, 41, 59, 0.7); border-radius: 15px; padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 300px;
        }

        table { width: 100%; border-collapse: collapse; }
        th {
            background: rgba(15, 23, 42, 0.8); padding: 15px; text-align: left;
            color: #a78bfa; border-bottom: 2px solid #334155; white-space: nowrap;
        }
        td { padding: 12px 15px; border-bottom: 1px solid #334155; }
        tr:hover { background: rgba(255, 255, 255, 0.05); }
        
        .val-currency { color: #4ade80; font-family: monospace; }
        .val-pixels { color: #a78bfa; font-weight: bold; }
        .decision-tag {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 0.8em; margin-right: 4px; margin-bottom: 2px;
        }
        .tag-speed { background: rgba(56, 189, 248, 0.2); color: #38bdf8; border: 1px solid rgba(56, 189, 248, 0.4); }
        .tag-cap { background: rgba(251, 146, 60, 0.2); color: #fb923c; border: 1px solid rgba(251, 146, 60, 0.4); }
        
        .calculating { opacity: 0.5; pointer-events: none; cursor: wait; }

        /* Styles for Manual Buttons (re-added from geo.html) */
        .manual-actions button {
            border: none; padding: 6px 10px; border-radius: 5px; color: white;
            font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.75em;
            margin: 2px 0;
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
        }
        .manual-actions button:disabled {
            background: #475569;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Summary List Styling */
        .upgrade-list {
            list-style: none;
            padding-left: 0;
            font-size: 0.9em;
        }
        .upgrade-list li {
            padding: 5px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }
        .upgrade-list li:last-child {
            border-bottom: none;
        }
        .upgrade-list-day {
            font-weight: bold;
            color: #4ade80;
            margin-right: 5px;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® GeoPixels Upgrade Planner</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="inactiveHours">Inactive Hours per Day (Sleep + Work):</label>
                <div class="slider-container">
                    <input type="range" id="inactiveHours" min="0" max="24" value="16" step="1">
                    <span class="slider-value" id="inactiveValue">16h</span>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card highlight">
                    <div class="stat-label">Total Pixels (Day 30)</div>
                    <div class="stat-value" id="totalPixels" style="color: #a78bfa;">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Regen Rate</div>
                    <div class="stat-value" id="finalRate">30s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Capacity</div>
                    <div class="stat-value" id="finalCap">60</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Leftover Currency</div>
                    <div class="stat-value" id="finalCurrency">0</div>
                </div>
            </div>
            
            <div class="button-row">
                <button class="optimize-btn" onclick="runAutoOptimize()">
                    ‚ö° Auto-Optimize (Aggressive Lookahead)
                </button>
                <button class="reset-btn" onclick="resetSim()">
                    ‚ùå Reset All Upgrades
                </button>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="data-layout">
            <div class="table-container">
                <h2 style="margin-bottom: 15px; color: #a78bfa;">Day-by-Day Simulation</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Day</th>
                            <th>Start Bank</th>
                            <th>Purchases</th>
                            <th>Daily Pixels</th>
                            <th>Total Pixels</th>
                            <th>End Bank</th>
                            <th>Manual Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>

            <div class="summary-container">
                <h2 style="margin-bottom: 15px; color: #a78bfa;">Upgrade Summary</h2>
                <ul class="upgrade-list" id="upgradeSummaryList">
                    </ul>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const CONSTANTS = {
            PIXELS_PER_CURRENCY: 5,
            START_CURRENCY: 1120,
            START_RATE: 30,
            START_CAP: 60,
            COST_CAP: 50,
            GAIN_CAP: 5,
            COST_SPEED: 500,
            GAIN_SPEED: 1,
            MIN_RATE: 15
        };

        // --- STATE ---
        let state = {
            inactiveHours: 16,
            // Upgrades are tracked by day: { dayNum: { speed: 0, cap: 0 } }
            upgrades: {} 
        };

        let chartInstance = null;

        // --- CORE SIMULATION LOGIC (From paint.html) ---

        // Helper: Clone stats object
        function cloneStats(s) {
            return { ...s };
        }

        // Helper: Project outcome from a specific day to Day 30 without changing state
        function projectRestOfMonth(startDay, currentStats, inactiveHours) {
            let simStats = cloneStats(currentStats);
            
            // Loop from current day to end of month
            // Note: CurrentStats has ALREADY SPENT on any upgrades for the current day
            for (let d = startDay; d <= 30; d++) {
                // 1. Calculate Daily Income based on current stats
                let activeSec = (24 - inactiveHours) * 3600;
                let inactiveSec = inactiveHours * 3600;
                
                // Active yield (uncapped)
                let activeYield = activeSec / simStats.regenRate;
                
                // Inactive yield (capped)
                let inactiveRaw = inactiveSec / simStats.regenRate;
                let inactiveYield = Math.min(inactiveRaw, simStats.capacity);
                
                let dailyPixels = activeYield + inactiveYield;
                let dailyEarnings = dailyPixels / CONSTANTS.PIXELS_PER_CURRENCY;
                
                // 2. Accumulate
                simStats.totalPixels += dailyPixels;
                simStats.currency += dailyEarnings;
            }
            return simStats.totalPixels;
        }

        // The "Brain" - Aggressive Optimizer (From paint.html)
        function findAggressivePath(inactiveHours) {
            let optimalUpgrades = {};
            
            // We need to track the state progressively as we make decisions
            let currentStats = {
                regenRate: CONSTANTS.START_RATE,
                capacity: CONSTANTS.START_CAP,
                currency: CONSTANTS.START_CURRENCY,
                totalPixels: 0
            };

            for (let day = 1; day <= 30; day++) {
                optimalUpgrades[day] = { speed: 0, cap: 0 };
                
                // THE AGGRESSIVE LOOP
                let keepBuying = true;
                
                while (keepBuying) {
                    let bestMove = 'none';
                    // 1. Calculate Baseline (Stop buying and just finish the month)
                    // Note: We MUST use a fresh copy of currentStats for the projection, because the projection function will add daily earnings to it, which shouldn't affect the real currentStats until the end of the day.
                    let baselineTotal = projectRestOfMonth(day, cloneStats(currentStats), inactiveHours);
                    let bestTotal = baselineTotal;

                    // 2. Simulate Buying Speed (if affordable)
                    let speedTotal = -1;
                    let canAffordSpeed = currentStats.currency >= CONSTANTS.COST_SPEED;
                    let notMaxed = currentStats.regenRate > CONSTANTS.MIN_RATE;
                    
                    if (canAffordSpeed && notMaxed) {
                        let tempStats = cloneStats(currentStats);
                        tempStats.currency -= CONSTANTS.COST_SPEED;
                        tempStats.regenRate -= CONSTANTS.GAIN_SPEED;
                        speedTotal = projectRestOfMonth(day, tempStats, inactiveHours);
                    }

                    // 3. Simulate Buying Cap (if affordable)
                    let capTotal = -1;
                    let canAffordCap = currentStats.currency >= CONSTANTS.COST_CAP;
                    
                    if (canAffordCap) {
                        let tempStats = cloneStats(currentStats);
                        tempStats.currency -= CONSTANTS.COST_CAP;
                        tempStats.capacity += CONSTANTS.GAIN_CAP;
                        capTotal = projectRestOfMonth(day, tempStats, inactiveHours);
                    }

                    // 4. Compare Scenarios
                    // We only buy if it STRICTLY improves the total pixel count
                    if (speedTotal > bestTotal) {
                        bestMove = 'speed';
                        bestTotal = speedTotal;
                    }
                    
                    // Note: Check cap against the best score so far (could be speed or baseline)
                    if (capTotal > bestTotal) {
                        bestMove = 'cap';
                        bestTotal = capTotal;
                    }

                    // 5. Execute Decision (update real stats AND optimalUpgrades)
                    if (bestMove === 'speed') {
                        currentStats.currency -= CONSTANTS.COST_SPEED;
                        currentStats.regenRate -= CONSTANTS.GAIN_SPEED;
                        optimalUpgrades[day].speed++;
                    } else if (bestMove === 'cap') {
                        currentStats.currency -= CONSTANTS.COST_CAP;
                        currentStats.capacity += CONSTANTS.GAIN_CAP;
                        optimalUpgrades[day].cap++;
                    } else {
                        // No move improved our score, or we are broke.
                        keepBuying = false; 
                    }
                } // End While Loop (Buying Spree)

                // 6. Process the Day Passing (Earn money for tomorrow)
                let activeSec = (24 - inactiveHours) * 3600;
                let inactiveSec = inactiveHours * 3600;
                
                let activeYield = activeSec / currentStats.regenRate;
                let inactiveRaw = inactiveSec / currentStats.regenRate;
                let inactiveYield = Math.min(inactiveRaw, currentStats.capacity);
                
                let dailyPixels = activeYield + inactiveYield;
                let dailyEarnings = dailyPixels / CONSTANTS.PIXELS_PER_CURRENCY;
                
                currentStats.totalPixels += dailyPixels;
                currentStats.currency += dailyEarnings;
            }

            return optimalUpgrades;
        }

        // Standard Simulator for UI Rendering (Modified to track more stats)
        function simulateFullMonth() {
            let history = [];
            let stats = {
                regenRate: CONSTANTS.START_RATE,
                capacity: CONSTANTS.START_CAP,
                currency: CONSTANTS.START_CURRENCY,
                totalPixels: 0,
                totalSpeedUpgrades: 0,
                totalCapUpgrades: 0
            };

            for (let day = 1; day <= 30; day++) {
                let startBank = stats.currency;
                
                // Get current upgrades for this day (may be empty if no manual/auto decision)
                let dayUpgrades = state.upgrades[day] || { speed: 0, cap: 0 };
                
                // --- Apply Costs & Stats (Before Earnings) ---
                let cost = (dayUpgrades.speed * CONSTANTS.COST_SPEED) + (dayUpgrades.cap * CONSTANTS.COST_CAP);
                stats.currency -= cost;
                stats.regenRate -= (dayUpgrades.speed * CONSTANTS.GAIN_SPEED);
                stats.capacity += (dayUpgrades.cap * CONSTANTS.GAIN_CAP);
                stats.totalSpeedUpgrades += dayUpgrades.speed;
                stats.totalCapUpgrades += dayUpgrades.cap;

                // --- Calculate Income (Earning) ---
                let activeSec = (24 - state.inactiveHours) * 3600;
                let inactiveSec = state.inactiveHours * 3600;
                
                let activeYield = activeSec / stats.regenRate;
                let inactiveRaw = inactiveSec / stats.regenRate;
                let inactiveYield = Math.min(inactiveRaw, stats.capacity);
                
                let dailyPixels = activeYield + inactiveYield;
                let dailyEarnings = dailyPixels / CONSTANTS.PIXELS_PER_CURRENCY;
                
                stats.totalPixels += dailyPixels;
                stats.currency += dailyEarnings; // Earning added at the end of the day

                history.push({
                    day: day,
                    startBank: startBank,
                    upgrades: dayUpgrades,
                    dailyPixels: dailyPixels,
                    totalPixels: stats.totalPixels,
                    endBank: stats.currency,
                    currentRate: stats.regenRate,
                    currentCap: stats.capacity
                });
            }
            return history;
        }

        // --- UI FUNCTIONS ---

        // Function to manually purchase an upgrade
        function buyUpgrade(day, type) {
            if (!state.upgrades[day]) {
                state.upgrades[day] = { speed: 0, cap: 0 };
            }
            
            // We don't check affordability here, the simulation/UI will reflect the bank balance
            // However, we should check max speed
            if (type === 'speed') {
                // Re-simulate up to this day to get current rate
                const historyUpToDay = simulateFullMonth().slice(0, day);
                const currentRate = historyUpToDay[day - 1] ? historyUpToDay[day - 1].currentRate : CONSTANTS.START_RATE;

                if (currentRate > CONSTANTS.MIN_RATE) {
                    state.upgrades[day].speed++;
                } else {
                    alert('Cannot buy Speed. Minimum rate (15s) has been reached or will be exceeded.');
                    return;
                }

            } else if (type === 'cap') {
                state.upgrades[day].cap++;
            }
            
            recalculateAndRender();
        }

        // Function to run the auto-optimizer
        function runAutoOptimize() {
            let btn = document.querySelector('.optimize-btn');
            btn.innerHTML = '‚öôÔ∏è Calculating...';
            btn.classList.add('calculating');

            setTimeout(() => {
                // The optimizer will generate a full upgrade path
                state.upgrades = findAggressivePath(state.inactiveHours);
                recalculateAndRender();
                
                btn.innerHTML = '‚ö° Auto-Optimize (Aggressive Lookahead)';
                btn.classList.remove('calculating');
            }, 50);
        }

        function resetSim() {
            state.upgrades = {};
            recalculateAndRender();
        }

        function recalculateAndRender() {
            let history = simulateFullMonth();
            updateUI(history);
            updateSummary(history);
        }

        function updateUI(history) {
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            
            history.forEach((row, index) => {
                let tr = document.createElement('tr');
                
                // Get stats from the END of the previous day (or start day 1)
                const previousDayStats = index > 0 ? history[index - 1] : { currentRate: CONSTANTS.START_RATE, currentCap: CONSTANTS.START_CAP, endBank: CONSTANTS.START_CURRENCY };

                // Get stats for the START of this day *before* spending
                // Note: The history row 'startBank' is the currency AFTER earning from the previous day, but before spending on this day.
                const preSpendBank = row.startBank;
                
                // Check if they can afford an *additional* upgrade
                const canAffordCap = preSpendBank >= (row.upgrades.cap * CONSTANTS.COST_CAP) + (row.upgrades.speed * CONSTANTS.COST_SPEED) + CONSTANTS.COST_CAP;
                const canAffordSpeed = preSpendBank >= (row.upgrades.cap * CONSTANTS.COST_CAP) + (row.upgrades.speed * CONSTANTS.COST_SPEED) + CONSTANTS.COST_SPEED;
                
                // Check max speed (currentRate is the rate *after* upgrades on this day)
                const isSpeedMaxed = row.currentRate <= CONSTANTS.MIN_RATE;


                let upgradeHtml = '';
                if(row.upgrades.speed > 0) upgradeHtml += `<span class="decision-tag tag-speed">‚ö° ${row.upgrades.speed}x Speed</span>`;
                if(row.upgrades.cap > 0) upgradeHtml += `<span class="decision-tag tag-cap">üì¶ ${row.upgrades.cap}x Cap</span>`;
                if(upgradeHtml === '') upgradeHtml = '<span style="opacity:0.3">‚Äî</span>';

                tr.innerHTML = `
                    <td style="color: #a78bfa; font-weight:bold;">${row.day}</td>
                    <td class="val-currency">${row.startBank.toFixed(2)}</td>
                    <td>${upgradeHtml}</td>
                    <td class="val-pixels">+${Math.round(row.dailyPixels).toLocaleString()}</td>
                    <td style="opacity: 0.8">${Math.round(row.totalPixels).toLocaleString()}</td>
                    <td class="val-currency">${row.endBank.toFixed(2)}</td>
                    <td class="manual-actions" style="white-space: nowrap;">
                        <button onclick="buyUpgrade(${row.day}, 'cap')" ${!canAffordCap ? 'disabled' : ''}>
                            Cap (+${CONSTANTS.GAIN_CAP})
                        </button>
                        <button onclick="buyUpgrade(${row.day}, 'speed')" ${!canAffordSpeed || isSpeedMaxed ? 'disabled' : ''}>
                            Speed (-${CONSTANTS.GAIN_SPEED}s)
                        </button>
                    </td>
                `;
                tableBody.appendChild(tr);
            });

            // Update Stats Cards
            let final = history[29];
            document.getElementById('totalPixels').innerText = Math.round(final.totalPixels).toLocaleString();
            document.getElementById('finalRate').innerText = final.currentRate + 's';
            document.getElementById('finalCap').innerText = final.currentCap + 'px';
            document.getElementById('finalCurrency').innerText = final.endBank.toFixed(2);

            // Update Chart
            updateChart(history);
        }

        // Function to create the Upgrade Summary List
        function updateSummary(history) {
            const summaryList = document.getElementById('upgradeSummaryList');
            summaryList.innerHTML = '';
            
            let totalSpeed = 0;
            let totalCap = 0;

            history.forEach(row => {
                if (row.upgrades.speed > 0 || row.upgrades.cap > 0) {
                    let li = document.createElement('li');
                    let summaryText = `<span class="upgrade-list-day">Day ${row.day}:</span>`;

                    if (row.upgrades.speed > 0) {
                        summaryText += ` ${row.upgrades.speed}x Speed Upgrade`;
                        totalSpeed += row.upgrades.speed;
                    }
                    if (row.upgrades.cap > 0) {
                        if (row.upgrades.speed > 0) summaryText += ' & ';
                        summaryText += ` ${row.upgrades.cap}x Cap Upgrade`;
                        totalCap += row.upgrades.cap;
                    }

                    li.innerHTML = summaryText;
                    summaryList.appendChild(li);
                }
            });

            if (summaryList.children.length === 0) {
                summaryList.innerHTML = '<li>No upgrades purchased yet.</li>';
            } else {
                // Add totals at the end
                let totalLi = document.createElement('li');
                totalLi.style.fontWeight = 'bold';
                totalLi.style.marginTop = '10px';
                totalLi.style.borderTop = '2px solid #a78bfa';
                totalLi.innerHTML = `<span style="color: #a78bfa;">Total Upgrades:</span> ${totalSpeed} Speed, ${totalCap} Cap`;
                summaryList.appendChild(totalLi);
            }
        }

        function updateChart(history) {
            const ctx = document.getElementById('mainChart').getContext('2d');
            if(chartInstance) chartInstance.destroy();

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: history.map(h => `Day ${h.day}`),
                    datasets: [{
                        label: 'Total Pixels Placed',
                        data: history.map(h => h.totalPixels),
                        borderColor: '#a78bfa',
                        backgroundColor: 'rgba(167, 139, 250, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#cbd5e1' } },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        x: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        // Init
        document.getElementById('inactiveHours').addEventListener('input', (e) => {
            document.getElementById('inactiveValue').innerText = e.target.value + 'h';
            state.inactiveHours = parseInt(e.target.value);
            recalculateAndRender();
        });

        // Run once on load
        resetSim(); 

    </script>
</body>
</html>
